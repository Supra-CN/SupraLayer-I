package cn.supra.supralayer_i.util;

import java.io.UnsupportedEncodingException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.content.Context;
import android.net.Uri;
import android.text.Spannable;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.style.ForegroundColorSpan;
import android.text.style.TextAppearanceSpan;

public class StringUtils {
	
	
	
	
	private static char[] hexChar = { '0', '1', '2', '3', '4', '5', '6', '7',
		'8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

	 public static final String GOOD_IRI_CHAR = "a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF";
	 
	 /**
	     *  Regular expression to match all IANA top-level domains for WEB_URL.
	     *  List accurate as of 2011/07/18.  List taken from:
	     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
	     *  This pattern is auto-generated by frameworks/ex/common/tools/make-iana-tld-pattern.py
	     */
	    public static final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =
	        "(?:"
	        + "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
	        + "|(?:biz|b[abdefghijmnorstvwyz])"
	        + "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])"
	        + "|d[ejkmoz]"
	        + "|(?:edu|e[cegrstu])"
	        + "|f[ijkmor]"
	        + "|(?:gov|g[abdefghilmnpqrstuwy])"
	        + "|h[kmnrtu]"
	        + "|(?:info|int|i[delmnoqrst])"
	        + "|(?:jobs|j[emop])"
	        + "|k[eghimnprwyz]"
	        + "|l[abcikrstuvy]"
	        + "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
	        + "|(?:name|net|n[acefgilopruz])"
	        + "|(?:org|om)"
	        + "|(?:pro|p[aefghklmnrstwy])"
	        + "|qa"
	        + "|r[eosuw]"
	        + "|s[abcdeghijklmnortuvyz]"
	        + "|(?:tel|travel|t[cdfghjklmnoprtvwz])"
	        + "|u[agksyz]"
	        + "|v[aceginu]"
	        + "|w[fs]"
	        + "|(?:\u03b4\u03bf\u03ba\u03b9\u03bc\u03ae|\u0438\u0441\u043f\u044b\u0442\u0430\u043d\u0438\u0435|\u0440\u0444|\u0441\u0440\u0431|\u05d8\u05e2\u05e1\u05d8|\u0622\u0632\u0645\u0627\u06cc\u0634\u06cc|\u0625\u062e\u062a\u0628\u0627\u0631|\u0627\u0644\u0627\u0631\u062f\u0646|\u0627\u0644\u062c\u0632\u0627\u0626\u0631|\u0627\u0644\u0633\u0639\u0648\u062f\u064a\u0629|\u0627\u0644\u0645\u063a\u0631\u0628|\u0627\u0645\u0627\u0631\u0627\u062a|\u0628\u06be\u0627\u0631\u062a|\u062a\u0648\u0646\u0633|\u0633\u0648\u0631\u064a\u0629|\u0641\u0644\u0633\u0637\u064a\u0646|\u0642\u0637\u0631|\u0645\u0635\u0631|\u092a\u0930\u0940\u0915\u094d\u0937\u093e|\u092d\u093e\u0930\u0924|\u09ad\u09be\u09b0\u09a4|\u0a2d\u0a3e\u0a30\u0a24|\u0aad\u0abe\u0ab0\u0aa4|\u0b87\u0ba8\u0bcd\u0ba4\u0bbf\u0baf\u0bbe|\u0b87\u0bb2\u0b99\u0bcd\u0b95\u0bc8|\u0b9a\u0bbf\u0b99\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0bc2\u0bb0\u0bcd|\u0baa\u0bb0\u0bbf\u0b9f\u0bcd\u0b9a\u0bc8|\u0c2d\u0c3e\u0c30\u0c24\u0c4d|\u0dbd\u0d82\u0d9a\u0dcf|\u0e44\u0e17\u0e22|\u30c6\u30b9\u30c8|\u4e2d\u56fd|\u4e2d\u570b|\u53f0\u6e7e|\u53f0\u7063|\u65b0\u52a0\u5761|\u6d4b\u8bd5|\u6e2c\u8a66|\u9999\u6e2f|\ud14c\uc2a4\ud2b8|\ud55c\uad6d|xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-3e0b707e|xn\\-\\-45brj9c|xn\\-\\-80akhbyknj4f|xn\\-\\-90a3ac|xn\\-\\-9t4b11yi5a|xn\\-\\-clchc0ea0b2g2a9gcd|xn\\-\\-deba0ad|xn\\-\\-fiqs8s|xn\\-\\-fiqz9s|xn\\-\\-fpcrj9c3d|xn\\-\\-fzc2c9e2c|xn\\-\\-g6w251d|xn\\-\\-gecrj9c|xn\\-\\-h2brj9c|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-j6w193g|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-kprw13d|xn\\-\\-kpry57d|xn\\-\\-lgbbat1ad8j|xn\\-\\-mgbaam7a8h|xn\\-\\-mgbayh7gpa|xn\\-\\-mgbbh1a71e|xn\\-\\-mgbc0a9azcg|xn\\-\\-mgberp4a5d4ar|xn\\-\\-o3cw4h|xn\\-\\-ogbpf8fl|xn\\-\\-p1ai|xn\\-\\-pgbs0dh|xn\\-\\-s9brj9c|xn\\-\\-wgbh1c|xn\\-\\-wgbl6a|xn\\-\\-xkc2al3hye2a|xn\\-\\-xkc2dl3a5ee0h|xn\\-\\-yfro4i67o|xn\\-\\-ygbi2ammx|xn\\-\\-zckzah|xxx)"
	        + "|y[et]"
	        + "|z[amw]))";
	    
	    
	    public static final Pattern URL_PATTERN = Pattern.compile(
		        "((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
		         + "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
		         + "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
		         + "((?:(?:[" + GOOD_IRI_CHAR + "][" + GOOD_IRI_CHAR + "\\-]{0,64}\\.)+"   // named host
		         + TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
		         + "|(?:(?:25[0-5]|2[0-4]" // or ip address
		         + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
		         + "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
		         + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
		         + "|[1-9][0-9]|[0-9])))"
		         + "(?:\\:\\d{1,5})?)" // plus option port number
		         + "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
		         + "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
		         + "(?:\\b|$)"); // and finally, a word boundary or end of
		                         // input.  This is to stop foo.sure from
		                         // matching as foo.su
		        
	    public static final Pattern ACCEPTED_URI_SCHEMA = Pattern.compile(
	            "(?i)" + // switch on case insensitive matching
	            "(" +    // begin group for schema
	            "(?:http|https|file|su):\\/\\/" +
	            "|(?:inline|data|about|javascript):" +
	            ")" +
	            "(.*)" );
	    
	    public static final Pattern PHONE_NUM_PATTERN = Pattern.compile(
	            "^(?:\\(?[0\\+]?\\d{1,3}\\)?)[\\s-]?(?:0|\\d{1,4})[\\s-]?(?:(?:13\\d{9})|(?:\\d{7,8}))$" //国际手机号码
	    		+"|^(?:\\(?[0\\+]\\d{2,3}\\)?)[\\s-]?(?:(?:\\(0{1,3}\\))?[0\\d]{1,4})[\\s-](?:[\\d]{7,8}|[\\d]{3,4}[\\s-][\\d]{3,4})$" //国际区号+国内区号+电话号码
	    		+"|^(?:(?:\\(0{1,3}\\))?[0\\d]{1,4})[\\s-](?:[\\d]{7,8}|[\\d]{3,4}[\\s-][\\d]{3,4})$" //国内区号＋电话号码
	    		+"|^(?:[\\d]{7,8}|[\\d]{3,4}[\\s-][\\d]{3,4})$");
	
	/**
	 * 用正则表达式验证邮箱地址的有效性
	 * @param mail
	 * @return
	 */
	public static boolean checkEmail(String mail) {
		String regex = "\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*";
		Pattern p = Pattern.compile(regex);
		Matcher m = p.matcher(mail);
		return m.find();
	} 
	
	
	public static String toHexString(byte[] b) {
		StringBuilder sb = new StringBuilder(b.length * 2);
		for (int i = 0; i < b.length; i++) {
			sb.append(hexChar[(b[i] & 0xf0) >>> 4]);
			sb.append(hexChar[b[i] & 0x0f]);
		}
		return sb.toString();
	}
	
	
	public static String extractDirectoryPath(String path) {
		if ((path == null) || path.equals("") || path.equals("/")) {
			return "";
		}

		int lastSlashPos = path.lastIndexOf('/');

		if (lastSlashPos >= 0) {
			return path.substring(0, lastSlashPos); // strip off the slash
		} else {
			return ""; // we expect people to add + "/somedir on their own
		}
	}
	
	public static String extractFileName(String path) {

		if (path == null) {
			return null;
		}
		String newpath = path.replace('\\', '/');
		int start = newpath.lastIndexOf("/");
		if (start == -1) {
			start = 0;
		} else {
			start = start + 1;
		}
		String pageName = newpath.substring(start, newpath.length());

		return pageName;
	}
	
	
	/**
	 * 生成高亮文字
	 * 
	 * @param src
	 *            包含高亮字符串的整个字符串
	 * @param highlight
	 *            高亮文字
	 * @param highlightColor
	 *            高亮文字的颜色
	 * @return
	 */
	public static CharSequence highlightText(String src, String highlight,
			int highlightColor) {

		if (TextUtils.isEmpty(src) || TextUtils.isEmpty(highlight))
			return src;

		SpannableStringBuilder style = new SpannableStringBuilder(src);
		String tmpSrc = src.toLowerCase();
		String tmpHl = highlight.toLowerCase();
		int start = tmpSrc.indexOf(tmpHl);
		int end = start + highlight.length();
			
			
		while(start >= 0){
			try {
				style.setSpan(new ForegroundColorSpan(highlightColor), start,
						end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
			} catch (Exception e) {
				Log.e("StringUtils", "hightlightText.", e.fillInStackTrace());
			}
			start = tmpSrc.indexOf(tmpHl, end);
			end = start + highlight.length();
		}
		
		return style;
	}
	
	public static final CharSequence highlight(Context context, CharSequence target, CharSequence highlight, int styleResId){
		
		if(TextUtils.isEmpty(target) || TextUtils.isEmpty(highlight)){
			return target;
		}
		
		String tmpSrc = target.toString().toLowerCase();
		String tmpHl = highlight.toString().toLowerCase();
		int start = tmpSrc.indexOf(tmpHl);
		int end = start + highlight.length();
		
		SpannableStringBuilder style = new SpannableStringBuilder(target);
		while(start > -1){
		//if(start > -1){
			style.setSpan(new TextAppearanceSpan(context, styleResId), start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
			start = tmpSrc.indexOf(tmpHl, end);
			end = start + highlight.length();
		}
		return style;
	}
	
	public static final String getBaseUrl(String url){
		if(URL_PATTERN.matcher(url).matches()){
			Uri uri = Uri.parse(url);
			StringBuilder baseUrl = new StringBuilder();
			String schema = uri.getScheme();
			if(!TextUtils.isEmpty(schema)){
				baseUrl.append(schema);
			}else{
				baseUrl.append("http");
			}
			baseUrl.append("://").append(uri.getHost());
			int port = uri.getPort();
			if(port != -1){
				baseUrl.append(':').append(port);
			}
			baseUrl.append('/');
			return baseUrl.toString();
		}
		return url;
	}

    /**
     * Removes characters 'c' from the beginning and the end of the string
     */
    public static String trim(String s, char c) {
        if (s == null) {
            return null;
        }
        if (s.length() == 0) {
            return "";
        }

        int start = 0;
        int end = s.length()-1;

        while(s.charAt(start) == c) {
            if(++start >= end) {
                // The string is made by c only
                return "";
            }
        }

        while(s.charAt(end) == c) {
            if(--end <= start) {
                return "";
            }
        }

        return s.substring(start, end+1);
    }
    /**
     * This method is missing in CLDC 1.0 String implementation
     * from syncml
     */
    public static boolean equalsIgnoreCase(String string1, String string2) {
        // Strings are both null, return true
        if (string1 == null && string2 == null) {
            return true;
        }
        // One of the two is null, return false
        if (string1 == null || string2 == null) {
            return false;
        }
        // Both are not null, compare the lowercase strings
        if ((string1.toLowerCase()).equals(string2.toLowerCase())) {
            return true;
        } else {
            return false;
        }
    }
	
	
	

	  
	/**
	 * 取出url或文件名的后缀
	 * @param fullName
	 * @return
	 */
	public static  String extractSuffix(String fullName) {
		int pos = fullName.lastIndexOf('.');
		if(pos <= 0) {
			return "";
		}
		return fullName.substring(pos);
	}
	
	/**
	 * 验证字符串是否是合法的电话号码
	 * @param cs
	 * @return
	 */
	public static boolean isPhoneNumber(CharSequence cs){
		if(TextUtils.isEmpty(cs)){
			return false;
		}
		return PHONE_NUM_PATTERN.matcher(cs).find();
	}
	
	/**
	 * 单字节的纯英文或者纯数字，或英文数字组合都返回true，包含汉字等就返回为false
	 * @return
	 */
	public static boolean isPureEnglishString(final String str) {
		if (null != str) {
			try {
				return str.getBytes("UTF-8").length == str.length();
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
		}
		return false;
		
	}
	
	
	
	
	public static String extractPhoneNum(CharSequence cs){
		Pattern p = Pattern.compile("\\d");
		StringBuilder num = new StringBuilder();
		Matcher m = p.matcher(cs);
		while(m.find()){
			num.append(m.group());
		}
		return num.toString();
	}


	public static boolean checkMobile(String mobile) {
		String regex = "^[1-9]\\d*$";
		Pattern p = Pattern.compile(regex);
		Matcher m = p.matcher(mobile);
		return m.find();
	}


	public static boolean checkNationalTelCode(String code){
		String regex = "^(\\d{1,4})-?(\\d+)$";
		Pattern p = Pattern.compile(regex);
		Matcher m = p.matcher(code);
		return m.find();
	
	}


	/**
	 * 将windows下的字符串转换成linux的字符串
	 * @author androidyue
	 * @param content
	 * @return
	 */
	public static String winStr2Linux(String content) {
		if (TextUtils.isEmpty(content)) {
			return "";
		}
		StringBuffer buffer = new StringBuffer();
		char[] chars = content.toCharArray();
		char curChar;
		for (int i = 0; i < chars.length; i++) {
			curChar = chars[i];
			if (curChar != '\r') {
				buffer.append(curChar);
			}
		}
		return buffer.toString();
	}

}
